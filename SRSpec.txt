1.	Introduction

Purpose 
The purpose of this document is to build a simple social media application that will allow users to create and interact with
each others' posts.


Intended Audience and Reading Suggestions
This project will be mainly focused on social media users, specifically people who want to create posts to share their ideas.

Product Scope
The purpose of this simple social media application is to allow people to make posts that will stay publicated depending on the
interaction that other users have with the post. We plan to build a web application, much like Twitter or Reddit, where users 
will be able to log in with a username and create public posts about a selected topic. Other users of the web app will be able 
to see and interact other users' posts by commenting or liking. The more likes and comments a post has, the more visible it
becomes to other users.

2.	Overall Description

2.1	Product Perspective
    This simple social media web application is developed to exhibit communication between different software pieces. This web application will
be a standalone product with the purpose of learning more about software communication. It will provide an interface for users to log in and 
create public posts. The main focus of this application, however, will be exhibiting software communications as opposed to providing a 
visually pleasing user interface. 

2.2	Product Functions
The main product functions that will be used in this application will facilitate communication between client browsers and a web app server.
    1. Browser -> Server 
            Users will be able to use functions that let their browsers communicate with a centralized server holding saved data and additional 
        functions to manipulate saved data. For example, a function may be used by users to send data making up their posts to the server to be 
        saved in a database. A function may also be used to send the amount of likes a post has recieved from other users. 
    2. Server -> Browser 
            A server will also be able to use functions to communicate saved information (inside a database) to users' browsers. For example, 
        a server function will send saved posts from other users to any client browsers connecting with the server. The server may also use a 
        function to send information to client browsers regarding the lifespan or visibility of posts.
    3. Browser (local)
            Browsers may use local functions that do not require communication with the server. Such functions will generally be used to create
        a user interface for users to create posts and like posts. 
    4. Server (local)
            The server may use local functions that do not require communication with client browsers. Such functions will generally be used 
        to facilitate database use and locally calculate the lifespan and visibility of the post using information from the database. 

2.3	User Classes and Characteristics
    This application will only cater to one user class: the users. Users will be provided a user interface where they can view and interact with 
other user posts and create their own. To put in more technically, the user interface will give Users the ability to interact with a server containing 
a database. Browser-server communication, however, will be abstracted from the users to provide a simpler experience. They will, for the most part,  
interact with the user interface without having to think of any technical details about browser-server communication. 

2.4	Operating Environment
    We plan to host our web app on the Odin server. Any user will be able to access our app simply by searching up either mine or Marc's public directory. 
Users will just have to enter a username upon arrival to start using the application. The Odin server will hold database details that users can connect
to see other users' saved posts or to create and save their own posts via a browser user interface located in our public student directories.  

2.5	Design and Implementation Constraints
    Our main constraint will be memory space since each student in our Odin server is allocated a quota. If the database and its content proves to be 
too large, we may have to create a memory consolidation scheme to prevent our database from taking too much server memory space. We may also 
just choose to locate our database elsewhere. Our server will become a sort middle-man between user browsers and the database. 

2.6	User Documentation
    Since this web application will be relatively simple and minimal, with our main focus pointed towards establishing browser-server communication, 
user documenation will be provided in the app. A 'help' section will be provided for users and will detail how to use the application. As previously
stated, browser-server communication will be abstracted from the user experience to make application usage simpler. 

2.7	Assumptions and Dependencies
    A user interface will be provided to users by accessing our public student directories on Odin. The user interface will communicate with a NodeJS
server with the use of sockets via SocketIO. The NodeJS server will store user and post information on a MongoDB database. As this web application
requires the collaborate of different sofwtare technologies, complications and errors, if any, will most likely occur during socket
communciation between the user browser interface and the NodeJS server. 

3.	External Interface Requirements

3.1	User Interfaces
Describe the logical characteristics of each interface between the software product and the users. This may include sample screen images, any GUI
 standards or product family style guides that are to be followed, screen layout constraints, standard buttons and functions (e.g., help) that will
  appear on every screen, keyboard shortcuts, error message display standards, and so on. Define the software components for which a user interface
  is needed. Details of the user interface design should be documented in a separate user interface specification.

3.2	Hardware Interfaces
Describe the logical and physical characteristics of each interface between the software product and the hardware components of the system.
 This may include the supported device types, the nature of the data and control interactions between the software and the hardware, and communication
  protocols to be used.

3.3	Software Interfaces
Describe the connections between this product and other specific software components (name and version), including databases, operating systems, tools,
 libraries, and integrated commercial components. Identify the data items or messages coming into the system and going out and describe the purpose of each.
  Describe the services needed and the nature of communications. Refer to documents that describe detailed application programming interface protocols. Identify
   data that will be shared across software components. If the data sharing mechanism must be implemented in a specific way (for example, use of a global data area
    in a multitasking operating system), specify this as an implementation constraint.

3.4	Communications Interfaces
Describe the requirements associated with any communications functions required by this product, including e-mail, web browser, network server communications protocols,
 electronic forms, and so on. Define any pertinent message formatting. Identify any communication standards that will be used, such as FTP or HTTP. Specify any communication
  security or encryption issues, data transfer rates, and synchronization mechanisms.

4.	System Features
This template illustrates organizing the functional requirements for the product by system features, the major services provided by the product. You may prefer to organize
 this section by use case, mode of operation, user class, object class, functional hierarchy, or combinations of these, whatever makes the most logical sense for your product.

4.1	System Feature 1
Don’t really say “System Feature 1.” State the feature name in just a few words.

4.1.1	Description and Priority
	Provide a short description of the feature and indicate whether it is of High, Medium, or Low priority. You could also include specific priority component 
    ratings, such as benefit, penalty, cost, and risk (each rated on a relative scale from a low of 1 to a high of 9).

4.1.2	Stimulus/Response Sequences
	List the sequences of user actions and system responses that stimulate the behavior defined for this feature. These will correspond to the dialog
     elements associated with use cases.

4.1.3	Functional Requirements
	Itemize the detailed functional requirements associated with this feature. These are the software capabilities that must be present in order 
    for the user to carry out the services provided by the feature, or to execute the use case. Include how the product should respond to anticipated
     error conditions or invalid inputs. Requirements should be concise, complete, unambiguous, verifiable, and necessary. Use “TBD” as a placeholder
      to indicate when necessary information is not yet available.
	
	Each requirement should be uniquely identified with a sequence number or a meaningful tag of some kind.
	
REQ-1:	
REQ-2:	
